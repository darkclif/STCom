// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CHATPACKET_NETPACKETS_H_
#define FLATBUFFERS_GENERATED_CHATPACKET_NETPACKETS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

namespace NetPackets {

struct STCPacket;
struct STCPacketBuilder;

struct STCErrorPacket;
struct STCErrorPacketBuilder;

struct ClientJoinServer;
struct ClientJoinServerBuilder;

struct ClientChatMessage;
struct ClientChatMessageBuilder;

struct ServerAnnounce;
struct ServerAnnounceBuilder;

struct ServerChatMessage;
struct ServerChatMessageBuilder;

struct STCPacket FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef STCPacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_CONTENT = 6
  };
  uint16_t type() const {
    return GetField<uint16_t>(VT_TYPE, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *content() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CONTENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_TYPE, 2) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyVector(content()) &&
           verifier.EndTable();
  }
};

struct STCPacketBuilder {
  typedef STCPacket Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(uint16_t type) {
    fbb_.AddElement<uint16_t>(STCPacket::VT_TYPE, type, 0);
  }
  void add_content(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> content) {
    fbb_.AddOffset(STCPacket::VT_CONTENT, content);
  }
  explicit STCPacketBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<STCPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<STCPacket>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<STCPacket> CreateSTCPacket(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> content = 0) {
  STCPacketBuilder builder_(_fbb);
  builder_.add_content(content);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<STCPacket> CreateSTCPacketDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t type = 0,
    const std::vector<uint8_t> *content = nullptr) {
  auto content__ = content ? _fbb.CreateVector<uint8_t>(*content) : 0;
  return NetPackets::CreateSTCPacket(
      _fbb,
      type,
      content__);
}

struct STCErrorPacket FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef STCErrorPacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_TYPE = 4,
    VT_MESSAGE = 6
  };
  uint16_t error_type() const {
    return GetField<uint16_t>(VT_ERROR_TYPE, 0);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_TYPE, 2) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct STCErrorPacketBuilder {
  typedef STCErrorPacket Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error_type(uint16_t error_type) {
    fbb_.AddElement<uint16_t>(STCErrorPacket::VT_ERROR_TYPE, error_type, 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(STCErrorPacket::VT_MESSAGE, message);
  }
  explicit STCErrorPacketBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<STCErrorPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<STCErrorPacket>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<STCErrorPacket> CreateSTCErrorPacket(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  STCErrorPacketBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_error_type(error_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<STCErrorPacket> CreateSTCErrorPacketDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_type = 0,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return NetPackets::CreateSTCErrorPacket(
      _fbb,
      error_type,
      message__);
}

struct ClientJoinServer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClientJoinServerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NICK = 4,
    VT_PUB_KEY = 6
  };
  const ::flatbuffers::String *nick() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NICK);
  }
  const ::flatbuffers::Vector<uint8_t> *pub_key() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PUB_KEY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.VerifyString(nick()) &&
           VerifyOffset(verifier, VT_PUB_KEY) &&
           verifier.VerifyVector(pub_key()) &&
           verifier.EndTable();
  }
};

struct ClientJoinServerBuilder {
  typedef ClientJoinServer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nick(::flatbuffers::Offset<::flatbuffers::String> nick) {
    fbb_.AddOffset(ClientJoinServer::VT_NICK, nick);
  }
  void add_pub_key(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> pub_key) {
    fbb_.AddOffset(ClientJoinServer::VT_PUB_KEY, pub_key);
  }
  explicit ClientJoinServerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClientJoinServer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClientJoinServer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClientJoinServer> CreateClientJoinServer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> nick = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> pub_key = 0) {
  ClientJoinServerBuilder builder_(_fbb);
  builder_.add_pub_key(pub_key);
  builder_.add_nick(nick);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ClientJoinServer> CreateClientJoinServerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *nick = nullptr,
    const std::vector<uint8_t> *pub_key = nullptr) {
  auto nick__ = nick ? _fbb.CreateString(nick) : 0;
  auto pub_key__ = pub_key ? _fbb.CreateVector<uint8_t>(*pub_key) : 0;
  return NetPackets::CreateClientJoinServer(
      _fbb,
      nick__,
      pub_key__);
}

struct ClientChatMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClientChatMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT = 4
  };
  const ::flatbuffers::String *content() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyString(content()) &&
           verifier.EndTable();
  }
};

struct ClientChatMessageBuilder {
  typedef ClientChatMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_content(::flatbuffers::Offset<::flatbuffers::String> content) {
    fbb_.AddOffset(ClientChatMessage::VT_CONTENT, content);
  }
  explicit ClientChatMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClientChatMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClientChatMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClientChatMessage> CreateClientChatMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> content = 0) {
  ClientChatMessageBuilder builder_(_fbb);
  builder_.add_content(content);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ClientChatMessage> CreateClientChatMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *content = nullptr) {
  auto content__ = content ? _fbb.CreateString(content) : 0;
  return NetPackets::CreateClientChatMessage(
      _fbb,
      content__);
}

struct ServerAnnounce FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ServerAnnounceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_FRIENDLY_NAME = 6,
    VT_PUB_KEY = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *friendly_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FRIENDLY_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *pub_key() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PUB_KEY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_FRIENDLY_NAME) &&
           verifier.VerifyString(friendly_name()) &&
           VerifyOffset(verifier, VT_PUB_KEY) &&
           verifier.VerifyVector(pub_key()) &&
           verifier.EndTable();
  }
};

struct ServerAnnounceBuilder {
  typedef ServerAnnounce Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ServerAnnounce::VT_NAME, name);
  }
  void add_friendly_name(::flatbuffers::Offset<::flatbuffers::String> friendly_name) {
    fbb_.AddOffset(ServerAnnounce::VT_FRIENDLY_NAME, friendly_name);
  }
  void add_pub_key(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> pub_key) {
    fbb_.AddOffset(ServerAnnounce::VT_PUB_KEY, pub_key);
  }
  explicit ServerAnnounceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ServerAnnounce> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ServerAnnounce>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ServerAnnounce> CreateServerAnnounce(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> friendly_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> pub_key = 0) {
  ServerAnnounceBuilder builder_(_fbb);
  builder_.add_pub_key(pub_key);
  builder_.add_friendly_name(friendly_name);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ServerAnnounce> CreateServerAnnounceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *friendly_name = nullptr,
    const std::vector<uint8_t> *pub_key = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto friendly_name__ = friendly_name ? _fbb.CreateString(friendly_name) : 0;
  auto pub_key__ = pub_key ? _fbb.CreateVector<uint8_t>(*pub_key) : 0;
  return NetPackets::CreateServerAnnounce(
      _fbb,
      name__,
      friendly_name__,
      pub_key__);
}

struct ServerChatMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ServerChatMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT = 4
  };
  const ::flatbuffers::String *content() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyString(content()) &&
           verifier.EndTable();
  }
};

struct ServerChatMessageBuilder {
  typedef ServerChatMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_content(::flatbuffers::Offset<::flatbuffers::String> content) {
    fbb_.AddOffset(ServerChatMessage::VT_CONTENT, content);
  }
  explicit ServerChatMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ServerChatMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ServerChatMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ServerChatMessage> CreateServerChatMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> content = 0) {
  ServerChatMessageBuilder builder_(_fbb);
  builder_.add_content(content);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ServerChatMessage> CreateServerChatMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *content = nullptr) {
  auto content__ = content ? _fbb.CreateString(content) : 0;
  return NetPackets::CreateServerChatMessage(
      _fbb,
      content__);
}

inline const NetPackets::STCPacket *GetSTCPacket(const void *buf) {
  return ::flatbuffers::GetRoot<NetPackets::STCPacket>(buf);
}

inline const NetPackets::STCPacket *GetSizePrefixedSTCPacket(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<NetPackets::STCPacket>(buf);
}

inline bool VerifySTCPacketBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<NetPackets::STCPacket>(nullptr);
}

inline bool VerifySizePrefixedSTCPacketBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<NetPackets::STCPacket>(nullptr);
}

inline void FinishSTCPacketBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NetPackets::STCPacket> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSTCPacketBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NetPackets::STCPacket> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace NetPackets

#endif  // FLATBUFFERS_GENERATED_CHATPACKET_NETPACKETS_H_
